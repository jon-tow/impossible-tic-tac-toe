<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Impossible Tic-Tac-Toe</title>

  <!-- Impossible Tic-Tac-Toe Styling. -->
  <style>
    :root {
      --main-color: rgb(97, 55, 248);
      --tertiary-color: rgb(238, 238, 238);
      --inner-shadow: inset 0 0 8px rgba(51, 45, 41, 0.3);
      --outer-shadow: 0 1px 8px rgba(51, 45, 41, 0.4);
      --background-color: #F8F8F8;
    }

    html {
      height: 100vh;
    }

    body {
      height: 100vh;
      margin: 0 auto;
      width: 100%;
      font-family: 'Avenir', 'Helvetica', sans-serif;
      color: rgb(85, 84, 84);
      background-color: white;
    }

    button {
      outline: 0;
    }

    .game-div {
      border-radius: 5px;
      display: grid;
      grid-template-rows: 15% 10% 50% 25%;
      grid-auto-rows: minmax(120px, auto);
      justify-content: center;
      align-items: center;
      height: 100%;
      width: 100%;
    }

    .title-div {
      display: flex;
      flex-direction: row;
      justify-content: center;
      width: 100%;
      height: 100%;
    }

    .alert-div {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
      color: var(--main-color);
    }

    .board-div {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
      font-size: 1.6em;
      background-color: rgba(237, 234, 255, 0.822);
      -moz-box-shadow: var(--outer-shadow);
      -webkit-box-shadow: var(--outer-shadow);
      box-shadow: var(--outer-shadow);
    }

    .board-table {
      border-collapse: collapse;
      height: 100%;
      width: 100%;
    }

    .board-table td {
      width: 33%;
      height: 33%;
      font-size: 2.2em;
      font-weight: 900;
      text-align: center;
    }

    .board-table td:active {
      -moz-box-shadow: var(--inner-shadow);
      -webkit-box-shadow: var(--inner-shadow);
      box-shadow: var(--inner-shadow);
    }

    .board-table td:hover {
      content: 'X';
    }

    .restart-div {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      height: 100%;
    }

    .restart-game-btn {
      background-color: white;
      color: var(--main-color);
      border: none;
      font-size: 1.2em;
      border-radius: 5px;
      width: 100%;
      height: 70px;
      display: block;
      text-transform: uppercase;
    }

    .restart-game-btn:active {
      background-color: var(--tertiary-color);
      box-shadow: var(--inner-shadow);
    }

    .restart-game-btn:hover {
      box-shadow: var(--inner-shadow);
    }
  </style>
</head>

<body>

  <!-- Impossible Tic-Tac-Toe Layout. -->
  <div class="game-div" id="game">
    <div class="title-div">
      <h1 id="title">Impossible Tic-Tac-Toe</h1>
    </div>
    <div class="alert-div">
      <h1 id="alert-label"></h1>
    </div>
    <div class="board-div">
      <table class="board-table" id="board-table">
        <tr>
          <td style="border-right: 4px solid rgb(122, 98, 255);
                      border-bottom: 4px solid rgb(122, 98, 255)"></td>
          <td style="border-right: 4px solid rgb(122, 98, 255);
                      border-bottom: 4px solid rgb(122, 98, 255)"></td>
          <td style="border-bottom: 4px solid rgb(122, 98, 255);"></td>
        </tr>
        <tr>
          <td style="border-right: 4px solid rgb(122, 98, 255);
                      border-bottom: 4px solid rgb(122, 98, 255)"></td>
          <td style="border-right: 4px solid rgb(122, 98, 255);
                      border-bottom: 4px solid rgb(122, 98, 255)"></td>
          <td style="border-bottom: 4px solid rgb(122, 98, 255);"></td>
        </tr>
        <tr>
          <td style="border-right: 4px solid rgb(122, 98, 255);"></td>
          <td style="border-right: 4px solid rgb(122, 98, 255);"></td>
          <td></td>
        </tr>
      </table>
    </div>
    <div class="restart-div">
      <button class="restart-game-btn" id="restart-game-btn">RESTART GAME</button>
    </div>
  </div>

  <!-- Impossible Tic-Tac-Toe Script -->
  <script type="text/javascript">

    // Grid size for classic 3 x 3 tic-tac-toe, and marker for empty cells.
    const ROWS = 3;
    const COLUMNS = 3;
    const NCELLS = ROWS * COLUMNS;
    const EMPTY = '';

    // Short helper functions.
    const get = (id) => document.getElementById(id);
    const queryAll = (selector) => document.querySelectorAll(selector);

    // Global objects to be used throughout play of tic-tac-toe.
    var human = { symbol: 'X', };
    var cpu = { symbol: 'O', };
    var gameState = {
      playerTurn: human,
      board: [
        EMPTY, EMPTY, EMPTY,
        EMPTY, EMPTY, EMPTY,
        EMPTY, EMPTY, EMPTY
      ],
    };

    // Game Logic.
    initImpossibleTicTacToe();

    /* 
     * initImpossibleTicTacToe() :: void -> void 
     *
     * Initializes the necessary event handlers needed to play the game. 
     */
    function initImpossibleTicTacToe() {
      initBoardHandler();
      initRestartGameHandler();
    }

    /* 
     * initBoardHandler() :: void -> void
     *
     * Assigns an event handler to each cell of the tic-tac-toe board table which
     * provide users a way to mark their moves.
     */
    function initBoardHandler() {
      let cells = queryAll('table td');
      for (let i = 0; i < NCELLS; i++) {        
        // Perform user move followed by computer's counter move.
        cells[i].onclick = function () {
          // Ignore clicks on cell if the game is over.
          if (isGameOver(gameState)) {
            return;
          }
          if (gameState.playerTurn === human && gameState.board[i] === EMPTY) {
            // Perform human move.    
            renderMove(gameState.board, i, this, human.symbol, 'rgb(122, 98, 255)');
            if (isGameOver(gameState) && isTie(gameState)) {
              gameAlert("DRAW!");
            } else if (isGameOver(gameState)) {
              gameAlert("YOU WIN!");
            } else {
              gameState.playerTurn = cpu;              
            }
            // Perform computer move.
            let bestMove = minimaxDecision(gameState);
            renderMove(gameState.board, bestMove, cells[bestMove], cpu.symbol, 'rgb(85, 84, 84)');
            if (isGameOver(gameState) && isTie(gameState)) {
              gameAlert("DRAW!");
            } else if (isGameOver(gameState)) {
              gameAlert("YOU LOSE!");
            } else {
              gameState.playerTurn = human;  
            }            
          }
        };
        // Mark cell with a dim placeholder when it is being hovered over.
        cells[i].onmouseover = function () {
          if (gameState.board[i] === EMPTY) {
            this.innerHTML = 'X';
            this.style.color = 'rgba(122, 98, 255, 0.45)';
          }
        };
        // Remove the placeholder marked by the mouseover.
        cells[i].onmouseout = function () {
          if (gameState.board[i] === EMPTY) {
            this.innerHTML = EMPTY;
          }
        };
      }
    }

    /* 
     * minimaxDecision(state) :: Object -> Integer
     * 
     * An algorithm for calculating minimax decisions on a tic-tac-toe board
     * Returns the move, here as an integer position, that leads to the outcome 
     * with the best payoff.
     * 
     * Note: The algorithm is based the one described on pg. 166 of the book
     *       Artificial Intelligence: A Modern Approach in the section Adversial 
     *       Search.
     */
    function minimaxDecision(state) {
      let moves = findCandidateMoves(state);  // Legal moves left in game.
      let bestMove;                           // Cpu's best possible move. 
      let bestPayoff = -Infinity;             // Corresponding score of best move. 
      for (let move of moves) {
        let payoff = minValue(result(state, move), 0);
        if (payoff > bestPayoff) {
          bestPayoff = payoff;
          bestMove = move;
        }
      }
      return bestMove;
    }

    /* 
     * maxValue(state, depth) :: (Object, Integer) -> Integer
     *  
     * Go through the whole game tree, all the way to the leaves (with help from 
     * minValue defined below), to determine the backed-up value of a state.
     * 
     * Note: The depth arg is used to count how far down the game tree we go
     *       before we reach a leaf. The earlier we reach a leaf, the better.
     */
    function maxValue(state, depth) {
      if (isGameOver(state)) {
        return getTerminalPayoff(state, depth);
      }
      let payoff = -Infinity;
      let moves = findCandidateMoves(state);
      for (let move of moves) {
        payoff = Math.max(payoff, minValue(result(state, move), depth + 1));
      }
      return payoff;
    }

    /* 
     * minValue(state, depth) :: (Object, Integer) -> Integer
     *  
     * Go through the entire game tree, all the way to the leaves (helped by 
     * maxValue defined above), to determine the backed-up value of a state.
     * 
     * Note: The depth arg is used to count how far down the game tree we go
     *       before we reach a leaf. The earlier we reach a leaf, the better.
     */
    function minValue(state, depth) {
      if (isGameOver(state)) {
        return getTerminalPayoff(state, depth);
      }
      let payoff = Infinity;
      let moves = findCandidateMoves(state);
      for (let move of moves) {
        payoff = Math.min(payoff, maxValue(result(state, move), depth + 1));
      }
      return payoff;
    }

    /* 
     * findCandidateMoves(state) :: Object -> Array
     * 
     * Returns an array of all possible/legal moves left to make 
     * in traversing the current game state tree.     
     */
    function findCandidateMoves(state) {
      let candidateMoves = [];
      const boardIterator = state.board.entries();
      for (let cell of boardIterator) {
        const value = cell[1];
        if (value == EMPTY) {
          const idx = cell[0];
          candidateMoves.push(idx);
        }
      }
      return candidateMoves;
    }

    /* 
     * result(state, move) :: (Object, Integer) -> Object
     * 
     * Returns the state of the game after player makes the specified move.
     */
    function result(state, move) {
      let movedState = JSON.parse(JSON.stringify(state));
      movedState.board[move] = state.playerTurn.symbol; // Mark the move on the board.
      movedState.playerTurn = state.playerTurn === human ? cpu : human;  // Alternate turns. 
      return movedState;
    }

    /* 
     * getTerminalPayoff(state, depth) :: (Object, Integer) -> Integer
     * 
     * Determines the final numeric value for a game that ends in a terminal 
     * state, given the depth at which it ended.     
     */
    function getTerminalPayoff(state, depth) {
      let payoff = 0;
      let board = state.board;
      const isWin = isRowWin(board) || isColumnWin(board) || isDiagonalWin(board);
      if (isWin) {
        const maxDepth = 9; // Max depth of gamestate tree (NEEDED TO MAKE CPU IMPOSSIBLE TO BEAT).        
        const winner = (state.playerTurn === human) ? cpu : human;
        payoff = (winner === cpu) ? (maxDepth - depth) : (-maxDepth - depth);
      } else if (isTie(state)) {
        payoff = 0 - depth;
      }
      return payoff;
    }

    /* 
     * isGameOver(state) :: Object -> boolean
     * 
     * Returns true if the game is completed via a win or tie.
     */
    function isGameOver(state) {
      let board = state.board;
      const isWin = isRowWin(board) || isColumnWin(board) || isDiagonalWin(board);
      return isWin || isTie(state);
    }

    /* 
     * isRowWin(board) :: Object -> boolean
     *
     * Check for a ROW-wise win across the tic-tac-toe board.
     */
    function isRowWin(board) {
      for (let i = 0; i <= NCELLS - 3; i += 3) {
        if (board[i] !== EMPTY
          && board[i] === board[i + 1]
          && board[i] === board[i + 2]) {
          return true;
        }
      }
      return false;
    }

    /* 
     * isColumnWin(board) :: Object -> boolean
     *
     * Check for a COLUMN-wise win across the tic-tac-toe board.
     */
    function isColumnWin(board) {
      for (let i = 0; i < COLUMNS; i++) {
        if (board[i] !== EMPTY
          && board[i] === board[i + 3]
          && board[i] === board[i + 6]) {
          return true;
        }
      }
      return false;
    }

    /* 
     * isDiagonalWin(board) :: Object -> boolean
     *
     * Check for a DIAGONAL-wise win across the tic-tac-toe board.
     */
    function isDiagonalWin(board) {
      return ((board[0] !== EMPTY
        && board[0] === board[4]
        && board[0] === board[8])
        ||
        (board[2] !== EMPTY
          && board[2] === board[4]
          && board[2] === board[6]));
    }

    /* 
     * isTie(state) :: Object -> boolean
     *
     * Check if the game has tied, that is no moves left.
     */
    function isTie(state) {
      return findCandidateMoves(state).length === 0;
    }

    /* 
     * initRestartGameHandler(startingPlayer) :: Object -> void
     *
     * Assigns an event handler to the restart game button which will 
     * provide users a way to restart games during or after they start
     * a match.
     */
    function initRestartGameHandler(startingPlayer) {
      let restartGameBtn = get('restart-game-btn');
      restartGameBtn.onclick = restartGame;
    }

    /*
     * restartGame() :: void -> void
     *
     * Take all necessary actions to restart the tic-tac-toe game.
     */
    function restartGame() {
      gameState.playerTurn = human;
      let alertLabel = get('alert-label');
      alertLabel.innerHTML = "";
      clearBoard();
    }

    // GUI Helper functions.
    function clearBoard() {
      let cells = queryAll('table td');
      for (let i = 0; i < NCELLS; i++) {
        gameState.board[i] = EMPTY;
        cells[i].innerHTML = EMPTY;
      }
    }
    function gameAlert(alertMsg) {
      let alertLabel = get('alert-label');
      alertLabel.innerHTML = alertMsg;
    }
    function renderMove(board, move, cellElement, symbol, color) {
      cellElement.style.color = color;
      cellElement.innerHTML = symbol;
      board[move] = symbol;
    }

    /* 
     * Test Minimax Decision. 
     */
    // testMinimaxDecision();
    function testMinimaxDecision() {
      // Test 1.
      let testState1 = {
        playerTurn: human,
        board: [
          'O', 'O', 'X',
          EMPTY, EMPTY, 'X',
          EMPTY, EMPTY, EMPTY
        ],
      };
      let bestMove1 = minimaxDecision(testState1);
      console.log(bestMove1 === 8);
      // Test 2.
      let testState2 = {
        playerTurn: cpu,
        board: [
          'O', EMPTY, 'X',
          EMPTY, 'O', 'X',
          'X', EMPTY, EMPTY
        ],
      }
      let bestMove2 = minimaxDecision(testState2);
      console.log(bestMove1 === 8);
    }
  </script>

</body>

</html>